<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sun-moon-star-star</title>
  
  
  <link href="https://sun-moon-star-star.github.io/atom.xml" rel="self"/>
  
  <link href="https://sun-moon-star-star.github.io/"/>
  <updated>2021-03-16T04:00:13.127Z</updated>
  <id>https://sun-moon-star-star.github.io/</id>
  
  <author>
    <name>sun-moon-star-star</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sysmon</title>
    <link href="https://sun-moon-star-star.github.io/2021/03/16/sysmon/"/>
    <id>https://sun-moon-star-star.github.io/2021/03/16/sysmon/</id>
    <published>2021-03-16T03:20:21.000Z</published>
    <updated>2021-03-16T04:00:13.127Z</updated>
    
    <content type="html"><![CDATA[<h4 id="sysmon"><a href="#sysmon" class="headerlink" title="sysmon"></a>sysmon</h4><ol><li>sysmon 执行一个无限循环，一开始每次循环休眠 20us，之后（1 ms 后）每次休眠时间倍增，最终每一轮都会休眠 10ms。</li><li>sysmon 中会进行 netpool（获取 fd 事件）、retake（抢占）、forcegc（按时间强制执行 gc），scavenge heap（释放自由列表中多余的项减少内存占用）等处理。</li></ol><p>和调度相关的，我们只关心 retake 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="keyword">int64</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="comment">// 遍历所有的 p</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; gomaxprocs; i++ &#123;</span><br><span class="line">_p_ := allp[i]</span><br><span class="line"><span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于 sysmon 线程记录被监控 p 的系统调用时间和运行时间</span></span><br><span class="line">pd := &amp;_p_.sysmontick</span><br><span class="line"><span class="comment">// p 的状态</span></span><br><span class="line">s := _p_.status</span><br><span class="line"><span class="keyword">if</span> s == _Psyscall &#123;</span><br><span class="line"><span class="comment">// P 处于系统调用之中，需要检查是否需要抢占</span></span><br><span class="line"><span class="comment">// Retake P from syscall if it&#x27;s there for more than 1 sysmon tick (at least 20us).</span></span><br><span class="line"><span class="comment">// _p_.syscalltick 用于记录系统调用的次数，在完成系统调用之后加 1</span></span><br><span class="line">t := <span class="keyword">int64</span>(_p_.syscalltick)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int64</span>(pd.syscalltick) != t &#123;</span><br><span class="line"><span class="comment">// pd.syscalltick != _p_.syscalltick，说明已经不是上次观察到的系统调用了，</span></span><br><span class="line"><span class="comment">// 而是另外一次系统调用，所以需要重新记录 tick 和 when 值</span></span><br><span class="line">pd.syscalltick = <span class="keyword">uint32</span>(t)</span><br><span class="line">pd.syscallwhen = now</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要满足下面三个条件中的任意一个，则抢占该 p，否则不抢占</span></span><br><span class="line"><span class="comment">// 1. p 的运行队列里面有等待运行的 goroutine</span></span><br><span class="line"><span class="comment">// 2. 没有无所事事的 p</span></span><br><span class="line"><span class="comment">// 3. 从上一次监控线程观察到 p 对应的 m 处于系统调用之中到现在已经超过 10 毫秒</span></span><br><span class="line"><span class="keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">incidlelocked(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> atomic.Cas(&amp;_p_.status, s, _Pidle) &#123;</span><br><span class="line"><span class="comment">// ……………………</span></span><br><span class="line">n++</span><br><span class="line">_p_.syscalltick++</span><br><span class="line"><span class="comment">// 寻找一新的 m 接管 p</span></span><br><span class="line">handoffp(_p_)</span><br><span class="line">&#125;</span><br><span class="line">incidlelocked(<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s == _Prunning &#123;</span><br><span class="line"><span class="comment">// P 处于运行状态，检查是否运行得太久了</span></span><br><span class="line"><span class="comment">// Preempt G if it&#x27;s running for too long.</span></span><br><span class="line"><span class="comment">// 每发生一次调度，调度器 ++ 该值</span></span><br><span class="line">t := <span class="keyword">int64</span>(_p_.schedtick)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int64</span>(pd.schedtick) != t &#123;</span><br><span class="line">pd.schedtick = <span class="keyword">uint32</span>(t)</span><br><span class="line">pd.schedwhen = now</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pd.schedtick == t 说明(pd.schedwhen ～ now)这段时间未发生过调度</span></span><br><span class="line"><span class="comment">// 这段时间是同一个goroutine一直在运行，检查是否连续运行超过了 10 毫秒</span></span><br><span class="line"><span class="keyword">if</span> pd.schedwhen+forcePreemptNS &gt; now &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 连续运行超过 10 毫秒了，发起抢占请求</span></span><br><span class="line">preemptone(_p_)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uint32</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码来看，主要会对处于 _Psyscall 和 _Prunning 状态的 p 进行抢占。</p><h4 id="抢占进行系统调用的-P"><a href="#抢占进行系统调用的-P" class="headerlink" title="抢占进行系统调用的 P"></a>抢占进行系统调用的 P</h4><p>当 P 处于 _Psyscall 状态时，表明对应的 goroutine 正在进行系统调用。如果抢占 p，需要满足几个条件：</p><ol><li>p 的本地运行队列里面有等待运行的 goroutine。这时 p 绑定的 g 正在进行系统调用，无法去执行其他的 g，因此需要接管 p 来执行其他的 g。</li><li>没有“无所事事”的 p。sched.nmspinning 和 sched.npidle 都为 0，这就意味着没有“找工作”的 m，也没有空闲的 p，大家都在“忙”，可能有很多工作要做。因此要抢占当前的 p，让它来承担一部分工作。</li><li>从上一次监控线程观察到 p 对应的 m 处于系统调用之中到现在已经超过 10 毫秒。这说明系统调用所花费的时间较长，需要对其进行抢占，以此来使得 retake 函数返回值不为 0，这样，会保持 sysmon 线程 20 us 的检查周期，提高 sysmon 监控的实时性。</li></ol><p>注意，原代码是用的三个与条件，三者都要满足才会执行下面的 continue，也就是不进行抢占。因此要想进行抢占的话，只需要三个条件有一个不满足就行了。于是就有了上述三种情况。</p><p>确定要抢占当前 p 后，先使用原子操作将 p 的状态修改为 _Pidle，最后调用 handoffp 进行抢占。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handoffp</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果 p 本地有工作或者全局有工作，需要绑定一个 m</span></span><br><span class="line"><span class="keyword">if</span> !runqempty(_p_) || sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">startm(_p_, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ……………………</span></span><br><span class="line"><span class="comment">// 所有其它 p 都在运行 goroutine，说明系统比较忙，需要启动 m</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) == <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;sched.nmspinning, <span class="number">0</span>, <span class="number">1</span>) &#123; <span class="comment">// <span class="doctag">TODO:</span> fast atomic</span></span><br><span class="line"><span class="comment">// p 没有本地工作，启动一个自旋 m 来找工作</span></span><br><span class="line">startm(_p_, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// ……………………</span></span><br><span class="line"><span class="comment">// 全局队列有工作</span></span><br><span class="line"><span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">startm(_p_, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ……………………</span></span><br><span class="line"><span class="comment">// 没有工作要处理，把 p 放入全局空闲队列</span></span><br><span class="line">pidleput(_p_)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handoffp 再次进行场景判断，以调用 startm 启动一个工作线程来绑定 p，使得整体工作继续推进。</p><p>当 p 的本地运行队列或全局运行队列里面有待运行的 goroutine，说明还有很多工作要做，调用 startm(<em>p</em>, false) 启动一个 m 来结合 p，继续工作。</p><p>当除了当前的 p 外，其他所有的 p 都在运行 goroutine，说明天下太平，每个人都有自己的事做，唯独自己没有。为了全局更快地完成工作，需要启动一个 m，且要使得 m 处于自旋状态，和 p 结合之后，尽快找到工作。</p><p>最后，如果实在没有工作要处理，就将 p 放入全局空闲队列里。</p><p>我们接着来看 startm 函数都做了些什么：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/proc.go</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 调用 m 来绑定 p，如果没有 m，那就新建一个</span></span><br><span class="line"><span class="comment">// 如果 p 为空，那就尝试获取一个处于空闲状态的 p，如果找到 p，那就什么都不做</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startm</span><span class="params">(_p_ *p, spinning <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 没有指定 p 则需要从全局空闲队列中获取一个 p</span></span><br><span class="line">_p_ = pidleget()</span><br><span class="line"><span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">if</span> spinning &#123;</span><br><span class="line"><span class="comment">// 如果找到 p，放弃。还原全局处于自旋状态的 m 的数量</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;startm: negative nmspinning&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有空闲的 p，直接返回</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 m 空闲队列中获取正处于睡眠之中的工作线程，</span></span><br><span class="line"><span class="comment">// 所有处于睡眠状态的 m 都在此队列中</span></span><br><span class="line">mp := mget()</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">if</span> mp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果没有找到 m</span></span><br><span class="line"><span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">if</span> spinning &#123;</span><br><span class="line"><span class="comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span></span><br><span class="line">fn = mspinning</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建新的工作线程</span></span><br><span class="line">newm(fn, _p_)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mp.spinning &#123;</span><br><span class="line">throw(<span class="string">&quot;startm: m is spinning&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;startm: m has p&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> spinning &amp;&amp; !runqempty(_p_) &#123;</span><br><span class="line">throw(<span class="string">&quot;startm: p has runnable gs&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span></span><br><span class="line">mp.spinning = spinning</span><br><span class="line"><span class="comment">// 设置 m 马上要结合的 p</span></span><br><span class="line">mp.nextp.set(_p_)</span><br><span class="line"><span class="comment">// 唤醒 m</span></span><br><span class="line">notewakeup(&amp;mp.park)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先处理 p 为空的情况，直接从全局空闲 p 队列里找，如果没找到，则直接返回。如果设置了 spinning 为 true 的话，还需要还原全局的处于自旋状态的 m 的数值：&amp;sched.nmspinning 。</p><p>搞定了 p，接下来看 m。先调用 mget 函数从全局空闲的 m 队列里获取一个 m，如果没找到 m，则要调用 newm 新创建一个 m，并且如果设置了 spinning 为 true 的话，先要设置好 mstartfn：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mspinning</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// startm&#x27;s caller incremented nmspinning. Set the new M&#x27;s spinning.</span></span><br><span class="line">    getg().m.spinning =<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，启动 m 后，在 mstart1 函数里，进入 schedule 循环前，执行 mstartfn 函数，使得 m 处于自旋状态。</p><p>接下来是正常情况下（找到了 p 和 m）的处理：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mp.spinning = spinning</span><br><span class="line"><span class="comment">// 设置 m 马上要结合的 p</span></span><br><span class="line">mp.nextp.set(_p_)</span><br><span class="line"><span class="comment">// 唤醒 m</span></span><br><span class="line">notewakeup(&amp;mp.park)</span><br></pre></td></tr></table></figure><p>设置 nextp 为找到的 p，调用 notewakeup 唤醒 m。之前我们讲 findrunnable 函数的时候，对于最后没有找到工作的 m，我们调用 notesleep(&amp;<em>g</em>.m.park)，使得 m 进入睡眠状态。现在终于有工作了，需要老将出山，将其唤醒：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/lock_futex.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notewakeup</span><span class="params">(n *note)</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置 n.key = 1, 被唤醒的线程通过查看该值是否等于 1</span></span><br><span class="line"><span class="comment">// 来确定是被其它线程唤醒还是意外从睡眠中苏醒</span></span><br><span class="line">old := atomic.Xchg(key32(&amp;n.key), <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> old != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;notewakeup - double wakeup (&quot;</span>, old, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">throw(<span class="string">&quot;notewakeup - double wakeup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">futexwakeup(key32(&amp;n.key), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>notewakeup 函数首先使用 atomic.Xchg 设置 note.key 值为 1，这是为了使被唤醒的线程可以通过查看该值是否等于 1 来确定是被其它线程唤醒还是意外从睡眠中苏醒了过来。如果该值为 1 则表示是被唤醒的，可以继续工作，但如果该值为 0 则表示是意外苏醒，需要再次进入睡眠。</p></blockquote><p>调用 futexwakeup 来唤醒工作线程，它和 futexsleep 是相对的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">futexwakeup</span><span class="params">(addr *<span class="keyword">uint32</span>, cnt <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 调用 futex 函数唤醒工作线程</span></span><br><span class="line">ret := futex(unsafe.Pointer(addr), _FUTEX_WAKE, cnt, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> ret &gt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ……………………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>futex 由汇编语言实现，前面已经分析过，这里就不重复了。主要内容就是先准备好参数，然后进行系统调用，由内核唤醒线程。</p><blockquote><p>内核在完成唤醒工作之后当前工作线程从内核返回到 futex 函数继续执行 SYSCALL 指令之后的代码并按函数调用链原路返回，继续执行其它代码。而被唤醒的工作线程则由内核负责在适当的时候调度到 CPU 上运行。</p></blockquote><h4 id="抢占长时间运行的-P"><a href="#抢占长时间运行的-P" class="headerlink" title="抢占长时间运行的 P"></a>抢占长时间运行的 P</h4><p>我们知道，Go scheduler 采用的是一种称为协作式的抢占式调度，就是说并不强制调度，大家保持协作关系，互相信任。对于长时间运行的 P，或者说绑定在 P 上的长时间运行的 goroutine，sysmon 会检测到这种情况，然后设置一些标志，表示 goroutine 自己让出 CPU 的执行权，给其他 goroutine 一些机会。</p><p>接下来我们就来分析当 P 处于 _Prunning 状态的情况。sysmon 扫描每个 p 时，都会记录下当前调度器调度的次数和当前时间，数据记录在结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sysmontick <span class="keyword">struct</span>&#123;</span><br><span class="line">    schedtick   <span class="keyword">uint32</span></span><br><span class="line">    schedwhen   <span class="keyword">int64</span></span><br><span class="line">    syscalltick <span class="keyword">uint32</span></span><br><span class="line">    syscallwhen <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面两个字段记录调度器调度的次数和时间，后面两个字段记录系统调用的次数和时间。</p><p>在下一次扫描时，对比 sysmon 记录下的 p 的调度次数和时间，与当前 p 自己记录下的调度次数和时间对比，如果一致。说明 P 在这一段时间内一直在运行同一个 goroutine。那就来计算一下运行时间是否太长了。</p><p>如果发现运行时间超过了 10 ms，则要调用 preemptone(<em>p</em>) 发起抢占的请求：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptone</span><span class="params">(_p_ *p)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">mp := _p_.m.ptr()</span><br><span class="line"><span class="keyword">if</span> mp == <span class="literal">nil</span> || mp == getg().m &#123;</span><br><span class="line">returnfalse</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被抢占的 goroutine</span></span><br><span class="line">gp := mp.curg</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> || gp == mp.g0 &#123;</span><br><span class="line">returnfalse</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置抢占标志</span></span><br><span class="line">gp.preempt = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 在 goroutine 内部的每次调用都会比较栈顶指针和 g.stackguard0，</span></span><br><span class="line"><span class="comment">// 来判断是否发生了栈溢出。stackPreempt 非常大的一个数，比任何栈都大</span></span><br><span class="line"><span class="comment">// stackPreempt = 0xfffffade</span></span><br><span class="line">gp.stackguard0 = stackPreempt</span><br><span class="line">returntrue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上只是将 stackguard0 设置了一个很大的值，而检查 stackguard0 的地方在函数调用前的一段汇编代码里进行。</p><p>举一个简单的例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello qcrao.com!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tool compile -S main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>得到汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;.main STEXT size&#x3D;120 args&#x3D;0x0 locals&#x3D;0x48</span><br><span class="line">0x000000000(test26.go:5)    TEXT    &quot;&quot;.main(SB), $72-0</span><br><span class="line">0x000000000(test26.go:5)    MOVQ    (TLS), CX</span><br><span class="line">0x000900009(test26.go:5)    CMPQ    SP,16(CX)</span><br><span class="line">0x000d00013(test26.go:5)    JLS    113</span><br><span class="line">0x000f00015(test26.go:5)    SUBQ    $72, SP</span><br><span class="line">0x001300019(test26.go:5)    MOVQ    BP,64(SP)</span><br><span class="line">0x001800024(test26.go:5)    LEAQ    64(SP), BP</span><br><span class="line">0x001d00029(test26.go:5)    FUNCDATA    $0, gclocals·69c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">0x001d00029(test26.go:5)    FUNCDATA    $1, gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)</span><br><span class="line">0x001d00029(test26.go:6)    MOVQ    $0,&quot;&quot;..autotmp_0+48(SP)</span><br><span class="line">0x002600038(test26.go:6)    MOVQ    $0,&quot;&quot;..autotmp_0+56(SP)</span><br><span class="line">0x002f00047(test26.go:6)    LEAQ    type.string(SB), AX</span><br><span class="line">0x003600054(test26.go:6)    MOVQ    AX,&quot;&quot;..autotmp_0+48(SP)</span><br><span class="line">0x003b00059(test26.go:6)    LEAQ    &quot;&quot;.statictmp_0(SB), AX</span><br><span class="line">0x004200066(test26.go:6)    MOVQ    AX,&quot;&quot;..autotmp_0+56(SP)</span><br><span class="line">0x004700071(test26.go:6)    LEAQ    &quot;&quot;..autotmp_0+48(SP), AX</span><br><span class="line">0x004c00076(test26.go:6)    MOVQ    AX,(SP)</span><br><span class="line">0x005000080(test26.go:6)    MOVQ    $1,8(SP)</span><br><span class="line">0x005900089(test26.go:6)    MOVQ    $1,16(SP)</span><br><span class="line">0x006200098(test26.go:6)    PCDATA    $0, $1</span><br><span class="line">0x006200098(test26.go:6)    CALL    fmt.Println(SB)</span><br><span class="line">0x006700103(test26.go:7)    MOVQ    64(SP), BP</span><br><span class="line">0x006c00108(test26.go:7)    ADDQ    $72, SP</span><br><span class="line">0x007000112(test26.go:7)    RET</span><br><span class="line">0x007100113(test26.go:7)    NOP</span><br><span class="line">0x007100113(test26.go:5)    PCDATA    $0, $-1</span><br><span class="line">0x007100113(test26.go:5)    CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">0x007600118(test26.go:5)    JMP    0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x000000000(test26.go:5)    MOVQ    (TLS), CX</span><br></pre></td></tr></table></figure><p>将本地存储 tls 保存到 CX 寄存器中，（TLS）表示它所关联的 g，这里就是前面所讲到的 main gouroutine。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x000900009(test26.go:5)    CMPQ    SP,16(CX)</span><br></pre></td></tr></table></figure><p>比较 SP 寄存器（代表当前 main goroutine 的栈顶寄存器）和 16(CX)，我们看下 g 结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="comment">// goroutine 使用的栈</span></span><br><span class="line">    stack       stack   <span class="comment">// offset known to runtime/cgo</span></span><br><span class="line"><span class="comment">// 用于栈的扩张和收缩检查</span></span><br><span class="line">    stackguard0 <span class="keyword">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line"><span class="comment">// ……………………</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span>&#123;</span><br><span class="line">    lo <span class="keyword">uintptr</span></span><br><span class="line">    hi <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共 16 字节。而 16(CX) 表示 g 对象的第 16 个字节，跳过了 g 的第一个字段，也就是 g.stackguard0 字段。</p><p>如果 SP 小于 g.stackguard0，这是必然的，因为前面已经把 g.stackguard0 设置成了一个非常大的值，因此跳转到了 113 行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x007100113(test26.go:7)    NOP</span><br><span class="line">0x007100113(test26.go:5)    PCDATA    $0, $-1</span><br><span class="line">0x007100113(test26.go:5)    CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">0x007600118(test26.go:5)    JMP    0</span><br></pre></td></tr></table></figure><p>调用 runtime.morestack_noctxt 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;runtime&#x2F;asm_amd64.s</span><br><span class="line">TEXT runtime·morestack_noctxt(SB),NOSPLIT,$0</span><br><span class="line">    MOVL    $0, DX</span><br><span class="line">    JMP    runtime·morestack(SB)</span><br></pre></td></tr></table></figure><p>直接跳转到 morestack 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·morestack(SB),NOSPLIT,$0-0</span><br><span class="line">&#x2F;&#x2F; Cannot grow scheduler stack (m-&gt;g0).</span><br><span class="line">    get_tls(CX)</span><br><span class="line">&#x2F;&#x2F; BX &#x3D; g，g 表示 main goroutine</span><br><span class="line">    MOVQ    g(CX), BX</span><br><span class="line">&#x2F;&#x2F; BX &#x3D; g.m</span><br><span class="line">    MOVQ    g_m(BX), BX</span><br><span class="line">&#x2F;&#x2F; SI &#x3D; g.m.g0</span><br><span class="line">    MOVQ    m_g0(BX), SI</span><br><span class="line">    CMPQ    g(CX), SI</span><br><span class="line">    JNE    3(PC)</span><br><span class="line">    CALL    runtime·badmorestackg0(SB)</span><br><span class="line">    INT    $3</span><br><span class="line">&#x2F;&#x2F; ……………………</span><br><span class="line">&#x2F;&#x2F; Set g-&gt;sched to context in f.</span><br><span class="line">&#x2F;&#x2F; 将函数的返回地址保存到 AX 寄存器</span><br><span class="line">    MOVQ    0(SP), AX &#x2F;&#x2F; f&#39;s PC</span><br><span class="line">&#x2F;&#x2F; 将函数的返回地址保存到 g.sched.pc</span><br><span class="line">    MOVQ    AX,(g_sched+gobuf_pc)(SI)</span><br><span class="line">&#x2F;&#x2F; g.sched.g &#x3D; g</span><br><span class="line">    MOVQ    SI,(g_sched+gobuf_g)(SI)</span><br><span class="line">&#x2F;&#x2F; 取地址操作符，调用 morestack_noctxt 之前的 rsp</span><br><span class="line">    LEAQ    8(SP), AX &#x2F;&#x2F; f&#39;s SP</span><br><span class="line">&#x2F;&#x2F; 将 main 函数的栈顶地址保存到 g.sched.sp</span><br><span class="line">    MOVQ    AX,(g_sched+gobuf_sp)(SI)</span><br><span class="line">&#x2F;&#x2F; 将 BP 寄存器保存到 g.sched.bp</span><br><span class="line">    MOVQ    BP,(g_sched+gobuf_bp)(SI)</span><br><span class="line">&#x2F;&#x2F; newstack will fill gobuf.ctxt.</span><br><span class="line">&#x2F;&#x2F; Call newstack on m-&gt;g0&#39;s stack.</span><br><span class="line">&#x2F;&#x2F; BX &#x3D; g.m.g0</span><br><span class="line">    MOVQ    m_g0(BX), BX</span><br><span class="line">&#x2F;&#x2F; 将 g0 保存到本地存储 tls</span><br><span class="line">    MOVQ    BX, g(CX)</span><br><span class="line">&#x2F;&#x2F; 把 g0 栈的栈顶寄存器的值恢复到 CPU 的寄存器 SP，达到切换栈的目的，下面这一条指令执行之前，</span><br><span class="line">&#x2F;&#x2F; CPU 还是使用的调用此函数的 g 的栈，执行之后 CPU 就开始使用 g0 的栈了</span><br><span class="line">    MOVQ    (g_sched+gobuf_sp)(BX), SP</span><br><span class="line">&#x2F;&#x2F; 准备参数</span><br><span class="line">    PUSHQ    DX    &#x2F;&#x2F; ctxt argument</span><br><span class="line">&#x2F;&#x2F; 不返回</span><br><span class="line">    CALL    runtime·newstack(SB)</span><br><span class="line">    MOVQ    $0,0x1003&#x2F;&#x2F; crash if newstack returns</span><br><span class="line">    POPQ    DX    &#x2F;&#x2F; keep balance check happy</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure><p>主要做的工作就是将当前 goroutine，也就是 main goroutine 的和调度相关的信息保存到 g.sched 中，以便在调度到它执行时，可以恢复。</p><p>最后，将 g0 的地址保存到 tls 本地存储，并且切到 g0 栈执行之后的代码。继续调用 newstack 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newstack</span><span class="params">(ctxt unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// thisg = g0</span></span><br><span class="line">thisg := getg()</span><br><span class="line"><span class="comment">// ……………………</span></span><br><span class="line"><span class="comment">// gp = main goroutine</span></span><br><span class="line">gp := thisg.m.curg</span><br><span class="line"><span class="comment">// Write ctxt to gp.sched. We do this here instead of in</span></span><br><span class="line"><span class="comment">// morestack so it has the necessary write barrier.</span></span><br><span class="line">gp.sched.ctxt = ctxt</span><br><span class="line"><span class="comment">// ……………………</span></span><br><span class="line">morebuf := thisg.m.morebuf</span><br><span class="line">thisg.m.morebuf.pc = <span class="number">0</span></span><br><span class="line">thisg.m.morebuf.lr = <span class="number">0</span></span><br><span class="line">thisg.m.morebuf.sp = <span class="number">0</span></span><br><span class="line">thisg.m.morebuf.g = <span class="number">0</span></span><br><span class="line"><span class="comment">// 检查 g.stackguard0 是否被设置成抢占标志</span></span><br><span class="line">preempt := atomic.Loaduintptr(&amp;gp.stackguard0) == stackPreempt</span><br><span class="line"><span class="keyword">if</span> preempt &#123;</span><br><span class="line"><span class="keyword">if</span> thisg.m.locks != <span class="number">0</span> || thisg.m.mallocing != <span class="number">0</span> || thisg.m.preemptoff != <span class="string">&quot;&quot;</span> || thisg.m.p.ptr().status != _Prunning &#123;</span><br><span class="line"><span class="comment">// 还原 stackguard0 为正常值，表示我们已经处理过抢占请求了</span></span><br><span class="line">gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line"><span class="comment">// 不抢占，调用 gogo 继续运行当前这个 g，不需要调用 schedule 函数去挑选另一个 goroutine</span></span><br><span class="line">gogo(&amp;gp.sched) <span class="comment">// never return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ……………………</span></span><br><span class="line"><span class="keyword">if</span> preempt &#123;</span><br><span class="line"><span class="keyword">if</span> gp == thisg.m.g0 &#123;</span><br><span class="line">throw(<span class="string">&quot;runtime: preempt g0&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> thisg.m.p == <span class="number">0</span> &amp;&amp; thisg.m.locks == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;runtime: g is running but p is not&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Synchronize with scang.</span></span><br><span class="line">casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line"><span class="comment">// ……………………</span></span><br><span class="line"><span class="comment">// Act like goroutine called runtime.Gosched.</span></span><br><span class="line"><span class="comment">// 修改为 running，调度起来运行</span></span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line"><span class="comment">// 调用 gopreempt_m 把 gp 切换出去</span></span><br><span class="line">gopreempt_m(gp) <span class="comment">// never return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ……………………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉了很多暂时还看不懂的地方，留到后面再研究。只关注有关抢占相关的。第一次判断 preempt 标志是 true 时，检查了 g 的状态，发现不能抢占，例如它所绑定的 P 的状态不是 _Prunning，那就恢复它的 stackguard0 字段，下次就不会走这一套流程了。然后，调用 gogo(&amp;gp.sched) 继续执行当前的 goroutine。</p><p>中间又处理了很多判断流程，再次判断 preempt 标志是 true 时，调用 gopreempt_m(gp) 将 gp 切换出去。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopreempt_m</span><span class="params">(gp *g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">            traceGoPreempt()</span><br><span class="line">    &#125;</span><br><span class="line">    goschedImpl(gp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用 goschedImpl 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">status := readgstatus(gp)</span><br><span class="line"><span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">dumpgstatus(gp)</span><br><span class="line">throw(<span class="string">&quot;bad g status&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更改 gp 的状态</span></span><br><span class="line">casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line"><span class="comment">// 解除 m 和 g 的关系</span></span><br><span class="line">dropg()</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// 将 gp 放入全局可运行队列</span></span><br><span class="line">globrunqput(gp)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// 进入新一轮的调度循环</span></span><br><span class="line">schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 gp 的状态改为 _Grunnable，放入全局可运行队列，等待下次有 m 来全局队列找工作时才能继续运行，毕竟你已经运行这么长时间了，给别人一点机会嘛。</p><p>最后，调用 schedule() 函数进入新一轮的调度循环，会找出一个 goroutine 来运行，永不返回。</p><p>这样，关于 sysmon 线程在关于调度这块到底做了啥，我们已经回答完了。总结一下：</p><ol><li>抢占处于系统调用的 P，让其他 m 接管它，以运行其他的 goroutine。</li><li>将运行时间过长的 goroutine 调度出去，给其他 goroutine 运行的机会。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;sysmon&quot;&gt;&lt;a href=&quot;#sysmon&quot; class=&quot;headerlink&quot; title=&quot;sysmon&quot;&gt;&lt;/a&gt;sysmon&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;sysmon 执行一个无限循环，一开始每次循环休眠 20us，之后（1 ms 后）每次休眠时间倍</summary>
      
    
    
    
    
    <category term="golang" scheme="https://sun-moon-star-star.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>中国剩余定理</title>
    <link href="https://sun-moon-star-star.github.io/2021/03/12/zhongguoshengyudingli/"/>
    <id>https://sun-moon-star-star.github.io/2021/03/12/zhongguoshengyudingli/</id>
    <published>2021-03-11T17:01:45.000Z</published>
    <updated>2021-03-11T17:16:07.439Z</updated>
    
    <content type="html"><![CDATA[<h4 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;中国剩余定理&quot;&gt;&lt;a href=&quot;#中国剩余定理&quot; class=&quot;headerlink&quot; title=&quot;中国剩余定理&quot;&gt;&lt;/a&gt;中国剩余定理&lt;/h4&gt;</summary>
      
    
    
    
    
    <category term="data structure" scheme="https://sun-moon-star-star.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>hyperloglog</title>
    <link href="https://sun-moon-star-star.github.io/2021/03/11/hyperloglog/"/>
    <id>https://sun-moon-star-star.github.io/2021/03/11/hyperloglog/</id>
    <published>2021-03-11T10:00:23.000Z</published>
    <updated>2021-03-11T10:11:46.770Z</updated>
    
    <content type="html"><![CDATA[<h4 id="hyperloglog"><a href="#hyperloglog" class="headerlink" title="hyperloglog"></a>hyperloglog</h4><h6 id="伯努利实验"><a href="#伯努利实验" class="headerlink" title="伯努利实验"></a>伯努利实验</h6><pre><code>- 如果连续抛了n轮硬币，每轮抛到正面就不抛了，那么抛过最大次数的硬币期望为log2(n)- 如果存在抛过最大次数的硬币为n，那么期望上经历了2^n的轮</code></pre><h6 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h6><pre><code>- 数据集到数据集的映射，一般是数据量比较大的数据到整数的映射</code></pre><ol><li>计算出hash值</li><li>然后分桶</li><li>使用剩余的位数转为二进制未代表抛硬币的正反面，然后可以再转，然后设置最大的次数位</li></ol><h6 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h6><p>使用调和平均数算出来再乘以桶数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;hyperloglog&quot;&gt;&lt;a href=&quot;#hyperloglog&quot; class=&quot;headerlink&quot; title=&quot;hyperloglog&quot;&gt;&lt;/a&gt;hyperloglog&lt;/h4&gt;&lt;h6 id=&quot;伯努利实验&quot;&gt;&lt;a href=&quot;#伯努利实验&quot; class</summary>
      
    
    
    
    
    <category term="data structure" scheme="https://sun-moon-star-star.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>Direct Io</title>
    <link href="https://sun-moon-star-star.github.io/2021/02/19/directio/"/>
    <id>https://sun-moon-star-star.github.io/2021/02/19/directio/</id>
    <published>2021-02-19T09:13:33.000Z</published>
    <updated>2021-02-19T13:14:18.397Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Direct-Io"><a href="#Direct-Io" class="headerlink" title="Direct Io"></a>Direct Io</h4><p>@<a href="https://yarchive.net/comp/linux/o_direct.html">https://yarchive.net/comp/linux/o_direct.html</a><br>@<a href="https://blog.csdn.net/AXW2013/article/details/70242228">https://blog.csdn.net/AXW2013/article/details/70242228</a></p><h5 id="O-DIRECT，绕过缓冲区高速缓存，直接IO"><a href="#O-DIRECT，绕过缓冲区高速缓存，直接IO" class="headerlink" title="O_DIRECT，绕过缓冲区高速缓存，直接IO"></a>O_DIRECT，绕过缓冲区高速缓存，直接IO</h5><p>直接IO：Linux允许应用程序在执行磁盘IO时绕过缓冲区高速缓存，从用户空间直接将数据传递到文件或磁盘设备，称为直接IO（direct IO）或者裸IO（raw IO）。</p><p>应用场景：数据库系统，其高速缓存和IO优化机制均自成一体，无需内核消耗CPU时间和内存去完成相同的任务。<br>使用直接IO的弊端：可能会大大降低性能，内核对缓冲区告诉缓存做了不少优化，包括：按顺序预读取，在成簇磁盘块上执行IO，允许访问同一文件的多个进程共享高速缓存的缓冲区。</p><p>使用方法：在调用open函数打开文件或设备时指定O_DIRECT标志。<br>注意可能发生的不一致性：若一进程以O_DIRECT标志打开某文件，而另一进程以普通（即使用了高速缓存缓冲区）打开同一文件，则由直接IO所读写的数据与缓冲区高速缓存中内容之间不存在一致性，应尽量避免这一场景。</p><p>使用直接IO需要遵守的一些限制：</p><ul><li>用于传递数据的缓冲区，其内存边界必须对齐为块大小的整数倍</li><li>数据传输的开始点，即文件和设备的偏移量，必须是块大小的整数倍</li><li>待传递数据的长度必须是块大小的整数倍。<br>不遵守上述任一限制均将导致EINVAL错误。</li></ul><h5 id="O-SYNC，以同步方式写入文件"><a href="#O-SYNC，以同步方式写入文件" class="headerlink" title="O_SYNC，以同步方式写入文件"></a>O_SYNC，以同步方式写入文件</h5><p>功能：强制刷新内核缓冲区到输出文件。这是有必要的，因为为了数据安全，需要确保将数据真正写入磁盘或者磁盘的硬件告诉缓存中。</p><p>我们先熟悉一下同步IO相关定义和系统调用。</p><h5 id="同步IO数据完整性和同步IO文件完整性"><a href="#同步IO数据完整性和同步IO文件完整性" class="headerlink" title="同步IO数据完整性和同步IO文件完整性"></a>同步IO数据完整性和同步IO文件完整性</h5><p>同步IO的定义：某一IO操作，要么已成功完成到磁盘的数据传递，要么被诊断为不成功。</p><p>SUSv3定义的两种同步IO完成类型:</p><ul><li>synchronized IO data integrity completion：确保针对文件的一次更新传递了足够的信息（部分文件元数据）到磁盘，以便于之后对数据的获取。</li><li>synchronized IO file integrity completion：确保针对文件的一次更新传递了所有的信息（所有文件元数据）到磁盘，即使有些在后续对文件数据的操作并不需要。</li></ul><h5 id="用于控制文件IO内核缓冲的系统调用"><a href="#用于控制文件IO内核缓冲的系统调用" class="headerlink" title="用于控制文件IO内核缓冲的系统调用"></a>用于控制文件IO内核缓冲的系统调用</h5><ol><li>fsync</li></ol><p>作用：fsync()系统调用将使缓冲数据和fd相关的所有元数据都刷新到磁盘上。调用fsync会强制使文件处于Synchronized IO file integrity completion状态。</p><p>函数声明：int  fsync( int  fd);</p><p>函数返回值： 0: success, -1: error</p><ol start="2"><li>fdatasync<br>作用：fdatasync()系统调用的作用类似fsync()，只是强制文件处于synchronized IO data integrity compeletion状态。</li></ol><p>函数声明：int  fdatasync( int  fd);</p><p>函数返回值： 0: success, -1: error</p><p>与fsync的区别：fdatasync()可能会减少磁盘操作的次数，由fsync()调用请求的两次变成一次。例如，修改了文件的数据，而文件大小不变，那么调用fdatasync调用请求只强制进行了数据更新，相比之下，fsync()调用会强制将元数据传递到磁盘上，而元数据和文件数据通常驻留在磁盘的不同区域，更新这些数据需要反复在整个磁盘上执行寻道操作。</p><ol start="3"><li>sync系统调用<br>作用：sync()系统调用会使包含更新文件信息的所有内核缓冲区（即数据块、指针块、元数据等）刷新到磁盘上。</li></ol><p>函数声明：void  sync( void );</p><p>细节：若内容发生变化的内核缓冲区在30s内未经显式方式同步到磁盘上，则一条长期运行的内核线程会确保将其刷新到磁盘上。这一做法是为了规避缓冲区与相关磁盘文件内容长期处于不一致状态。</p><ol start="4"><li>使所有写入同步：O_SYNC</li></ol><p>调用open()函数时，如制定O_SYNC标志，则会使所有后续输出同步。</p><p>fd = open(pathname, O_WRONLY | O_SYNC);</p><p>作用：调用open后，每个write调用会自动将文件数据和元数据刷新到磁盘上，即按照Synchronized IO file integrity completion的要求执行写操作。</p><h5 id="有无O-SYNC性能对比"><a href="#有无O-SYNC性能对比" class="headerlink" title="有无O_SYNC性能对比"></a>有无O_SYNC性能对比</h5><img src="https://github.com/sun-moon-star-star/sun-moon-star-star.github.io/raw/master/images/md/directio.png"/><ul><li><p>采用O_SYNC标志（或者频繁调用fsync(), fdatasync()或sync()）对性能影响极大。</p></li><li><p>性能下降的直接表现为运行总用时大为增加：在缓冲区为1字节的情况下，运行时间相差1000多倍。</p></li><li><p>以O_SYNC标志执行写操作时运行总用时和CPU时间之间的巨大差异（1030 - 98.8），原因是系统在每个缓冲区中将数据向磁盘传递时会把程序阻塞起来。</p></li></ul><h4 id="IO缓冲层次关系"><a href="#IO缓冲层次关系" class="headerlink" title="IO缓冲层次关系"></a>IO缓冲层次关系</h4><p>先总结一下stdio函数库和  内核采用的缓冲这两级缓冲，然后用图说明两层缓冲机制和各种缓冲类型的控制机制。</p><img src="https://github.com/sun-moon-star-star/sun-moon-star-star.github.io/raw/master/images/md/directio2.png"/><ul><li>首先，通过stdio库将用户数据传递到stdio缓冲区，该缓冲区位于用户态内存区。</li><li>当缓冲区填满，stdio库会调用write()系统调用，将数据传递到内核高速缓冲区，该缓冲区位于内核态内存区。</li><li>最终，内核发起磁盘操作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Direct-Io&quot;&gt;&lt;a href=&quot;#Direct-Io&quot; class=&quot;headerlink&quot; title=&quot;Direct Io&quot;&gt;&lt;/a&gt;Direct Io&lt;/h4&gt;&lt;p&gt;@&lt;a href=&quot;https://yarchive.net/comp/linux/</summary>
      
    
    
    
    
    <category term="io" scheme="https://sun-moon-star-star.github.io/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议</title>
    <link href="https://sun-moon-star-star.github.io/2021/02/19/http/"/>
    <id>https://sun-moon-star-star.github.io/2021/02/19/http/</id>
    <published>2021-02-19T01:56:54.000Z</published>
    <updated>2021-02-19T13:14:11.413Z</updated>
    
    <content type="html"><![CDATA[<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h5><p>HTTP 是 HyperText Transfer Protocol（超文本传输协议）的缩写，它是互联网上应用最为广泛的一种网络协议，所有 WWW 文件都必须遵守这个标准。</p><p>伴随着计算机网络和浏览器的诞生，HTTP 1.0/1.1 也随之而来，它建立在 TCP 协议之上，处于计算机网络中的应用层，所以 HTTP 协议的瓶颈及其优化技巧都是基于 TCP 协议本身的特性，例如 TCP 建立连接的 3 次握手和断开连接的 4 次挥手，以及每次建立连接带来的 RTT 延迟时间等。</p><p>HTTP 1.0 与 1.1 的主要区别在于长连接支持、多路复用、带宽节约与数据压缩等，相对于 HTTP/2，本文将其通称为 HTTP/1。</p><h5 id="HTTP-1-的缺陷"><a href="#HTTP-1-的缺陷" class="headerlink" title="HTTP/1 的缺陷"></a>HTTP/1 的缺陷</h5><p><strong><em>连接无法复用</em></strong>：连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对大量小文件请求影响较大（没有达到最大窗口请求就被终止）。</p><p>HTTP/1.0 传输数据时，每次都需要重新建立连接，增加延迟。</p><p>HTTP/1.1 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。</p><p><strong><em>Head-Of-Line Blocking（HOLB，队头阻塞）</em></strong>：这会导致带宽无法被充分利用，以及后续健康请求被阻塞。HOLB 是指一系列包（package）因为第一个包被阻塞；当页面中需要请求很多资源的时候，HOLB 会导致在达到最大请求数量时，剩余的资源需要等待其它资源请求完成后才能发起请求。</p><p>HTTP 1.0：下个请求必须在前一个请求返回后才能发出，request-response对按序发生。显然，如果某个请求长时间没有返回，那么接下来的请求就全部阻塞了。</p><p>HTTP 1.1：尝试使用 pipeling 来解决，即浏览器可以一次性发出多个请求（同个域名、同一条 TCP 链接）。但 pipeling 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。所以，pipeling 只部分解决了 HOLB。</p><p><strong><em>协议开销大</em></strong>： HTTP/1 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。</p><p><strong><em>安全因素</em></strong>：HTTP/1 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</p><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p>2015 年，继承于 SPDY 的 HTTP/2 协议发布了。HTTP/2 是 HTTP/1 的替代品，但它不是重写，协议中还保留着第一代的一些内容，比如 HTTP 方法、状态码与语义等都与 HTTP/1 一样。</p><p>HTTP/2 基于SPDY3，专注于性能，最大的一个目标是在用户和网站间只用一个连接。</p><p>HTTP/2 由两个规范组成：</p><p>Hypertext Transfer Protocol version 2 - RFC7540</p><p>HPACK - Header Compression for HTTP/2 - RFC7541</p><p><strong><em>HTTP/2 特性二进制传输</em></strong>: </p><p>HTTP/2 采用二进制格式传输数据，而非 HTTP/1 的文本格式，二进制协议解析起来更高效。</p><p>HTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。</p><p>接下来我们介绍几个重要的概念：</p><p><strong><em>流（stream）</em></strong>：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）</p><p><strong><em>消息（message）</em></strong>：指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成</p><p><strong><em>帧（frame）</em></strong>：HTTP/2 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷等</p><p>HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。</p><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>在 HTTP/2 中引入了多路复用技术。多路复用很好地解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。</p><p>在 HTTP/2 中，有了二进制分帧之后，HTTP/2 不再依赖 TCP 链接去实现多流并行了，像前边提到的，在 HTTP/2 中。</p><ul><li><p>同域名下所有通信都在单个连接上完成。</p></li><li><p>单个连接可以承载任意数量的双向数据流。</p></li><li><p>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</p></li></ul><p>这一特性，使性能有了极大提升：</p><p>同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应，消除了因多个 TCP 连接而带来的延时和内存消耗</p><p>并行交错地发送多个请求，请求之间互不影响</p><p>并行交错地发送多个响应，响应之间互不干扰</p><p>在 HTTP/2 中，每个请求都可以带一个 31 bit 的优先值，数值越大优先级越低，0 表示最高优先级。有了这个优先值，客户端和服务器就可以在处理不同流时采取不同的策略，以最优的方式发送流、消息和帧。</p><h5 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a>Header 压缩</h5><p>在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千字节。</p><p>为了减少这块的资源消耗并提升性能， HTTP/2 对这些首部采取了压缩策略：</p><p>HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送</p><p>首部表在 HTTP/2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新</p><p>每个新的首部键-值对要么被追加到当前表的末尾，要么替换表中之前的值</p><p>例如两个请求， 请求 1 发送了所有头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。</p><h5 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h5><p>Server Push 即服务端能通过 push 的方式将客户端需要的内容预先推送过去，也叫“cache push”。</p><p>可以想象以下情况：某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch。</p><p>例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。</p><p>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。</p><h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><p>虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的。</p><p>上文提到 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。</p><p>因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 <strong><em>HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据</em></strong>。</p><p>那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了，因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。</p><p>基于这个原因，Google 就自己架起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上，HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。</p><p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个 QUIC 功能。</p><h4 id="QUIC-功能"><a href="#QUIC-功能" class="headerlink" title="QUIC 功能"></a>QUIC 功能</h4><h5 id="0RTT"><a href="#0RTT" class="headerlink" title="0RTT"></a>0RTT</h5><p>通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。0RTT 建连可以说是 QUIC 相比 HTTP/2 最大的性能优势。那什么是 0RTT 建连呢？</p><p>这里面有两层含义:</p><p>1、传输层 0RTT 就能建立连接。</p><p>2、加密层 0RTT 就能建立加密连接。</p><p>因为这里考虑到安全性，我们就拿加了 LTS 的“安全的 HTTP 协议”HTTPS 来对比。HTTPS 的一次完全握手的建连过程，需要 3 个 RTT，就算是会话复用也需要至少 2 个 RTT。</p><p>而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密的基础上，并且 0RTT 的成功率相比 TLS 的会话记录单要高很多。</p><h5 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h5><p>QUIC 原生实现了多路复用功能，并且传输的单个数据流可以保证有序交付且不会影响其它数据流，这样的技术就解决了前边提到的 TCP 多路复用存在的问题。</p><p>同 HTTP/2 一样，同一个 QUIC 连接上可以创建多个 stream 来发送多个 HTTP 请求，但是，QUIC 是基于 UDP 的，因为一个连接上的多个 stream 之间没有依赖，所以不存在 HTTP/2 中的问题。比如下图中 stream2 丢了一个 UDP 包，不会影响后面跟着 Stream3 和 Stream4，不存在 TCP 队头阻塞。虽然 stream2 的那个包需要重新传，但是 stream3、stream4 的包无需等待就可以发给用户。</p><p>另外 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。而 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。</p><h5 id="加密认证的报文"><a href="#加密认证的报文" class="headerlink" title="加密认证的报文"></a>加密认证的报文</h5><p>TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改、注入和窃听，比如修改序列号与滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。</p><p>相比之下，QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。</p><p>这样只要是针对 QUIC 报文进行了任何修改，接收端都能够及时发现，有效地降低了安全风险。</p><p>Stream Frame 的报文头部，有认证；报文内容，全部经过加密。</p><h5 id="前向纠错机制"><a href="#前向纠错机制" class="headerlink" title="前向纠错机制"></a>前向纠错机制</h5><p>QUIC 协议有一个非常独特的特性，称为前向纠错（Forward Error Correction，FEC），每个数据包除了它本身的内容之外，还包括了部分其它数据包的数据，因此少量的丢包可以通过其它包的冗余数据直接组装而无需重传。</p><p>前向纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传次数。这会取得更好的效果，因为数据重传将会消耗更多的时间，包括确认数据包丢失、请求重传与等待新数据包等步骤。</p><p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包，当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>HTTP/1 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷</p><p>HTTP/2 通过多路复用、二进制流与 Header 压缩等技术，极大地提高了性能，但是还是存在一些问题</p><p>HTTP/3 抛弃 TCP 协议，以全新的视角重新设计 HTTP。其底层支撑是 QUIC 协议，该协议基于 UDP，有 UDP 特有的优势，同时它又取了 TCP 中的精华，实现了即快又可靠的协议</p><p>从 HTTP/1 到 HTTP/3，HTTP 协议经过不断进化，性能越来越高，在这个过程中，底层协议甚至从 TCP 改为了之前被认定为不适合 UDP，这其中不断探索的设计思想值得学习。虽然本文是简单的介绍，但已经把这一演进过程简单地总结了出来，希望读者能够有所收获。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h4&gt;&lt;h5 id=&quot;HTTP-协议&quot;&gt;&lt;a href=&quot;#HTTP-协议&quot; class=&quot;headerlink&quot; title=&quot;HTT</summary>
      
    
    
    
    
    <category term="http" scheme="https://sun-moon-star-star.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="https://sun-moon-star-star.github.io/2021/02/19/questions/"/>
    <id>https://sun-moon-star-star.github.io/2021/02/19/questions/</id>
    <published>2021-02-19T01:56:54.000Z</published>
    <updated>2021-02-19T13:13:35.224Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h4><ol><li><p>在文件系统中，也有类似的缓存。如果不想使用任何缓存，应该怎么做？如果调用mmap，使用了多少缓存？如果调用系统调用open + read，使用了多少缓存？如果调用fopen + fread，又使用了多少缓存？</p></li><li><p>管理节点通过udp心跳的方式感知数据节点是否可用，而计算节点通过tcp长链接的方式和数据节点交互。二者看到的状态是否存在不一致？如果是，你会如何解决？</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;面试&quot;&gt;&lt;a href=&quot;#面试&quot; class=&quot;headerlink&quot; title=&quot;面试&quot;&gt;&lt;/a&gt;面试&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在文件系统中，也有类似的缓存。如果不想使用任何缓存，应该怎么做？如果调用mmap，使用了多少缓存？如果调用系统调用open</summary>
      
    
    
    
    
    <category term="interview" scheme="https://sun-moon-star-star.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>tips</title>
    <link href="https://sun-moon-star-star.github.io/2021/02/11/tips/"/>
    <id>https://sun-moon-star-star.github.io/2021/02/11/tips/</id>
    <published>2021-02-11T08:32:24.000Z</published>
    <updated>2021-02-19T13:13:51.363Z</updated>
    
    <content type="html"><![CDATA[<h4 id="backend"><a href="#backend" class="headerlink" title="backend"></a>backend</h4><h5 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h5><ul><li>减少javascript,css,html内容本身的大小: 删除多余的空格、注释、tab等</li><li>压缩: 压缩的开销远小于传输的开销，带宽比较贵</li></ul><h5 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h5><ul><li>不要过于抽象以至于代码难以阅读</li></ul><h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><ul><li>时间开销大</li><li>难以阅读， 难度大</li><li>适合原子的功能，不适合做过于复杂的判断</li></ul><h5 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h5><ul><li>细分的时候要注意体系和理解性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;backend&quot;&gt;&lt;a href=&quot;#backend&quot; class=&quot;headerlink&quot; title=&quot;backend&quot;&gt;&lt;/a&gt;backend&lt;/h4&gt;&lt;h5 id=&quot;压缩&quot;&gt;&lt;a href=&quot;#压缩&quot; class=&quot;headerlink&quot; title=&quot;压</summary>
      
    
    
    
    
    <category term="tips" scheme="https://sun-moon-star-star.github.io/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>流量录制和回放</title>
    <link href="https://sun-moon-star-star.github.io/2021/02/10/liuliangluzhihehuifang/"/>
    <id>https://sun-moon-star-star.github.io/2021/02/10/liuliangluzhihehuifang/</id>
    <published>2021-02-10T07:35:34.000Z</published>
    <updated>2021-02-19T13:14:06.578Z</updated>
    
    <content type="html"><![CDATA[<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>将线上的真实请求流量录制下来，包含调用下游服务的流量。</p><h4 id="拦截点选择"><a href="#拦截点选择" class="headerlink" title="拦截点选择"></a>拦截点选择</h4><p>流量录制必然要在某个点上对流量进行拦截并镜像，常见的拦截方式如下：</p><ul><li>业务代码</li><li>rpc框架</li><li>语言标准库</li><li>libc</li><li>syscall</li><li>tcp/ip协议栈</li><li>网卡驱动</li></ul><p>分析:</p><ul><li>为了做到尽量无业务浸入、具体框架无关，业务代码和rpc框架拦截方式不适合。</li><li>syscal拦截成本高，到tcp/ip协议栈的时候线程等信息丢失更不容易区分，所以后面几种方式都不适合。</li></ul><p>综上，比较适合拦截的方式是libc、语言标准库。</p><ul><li>对于底层使用libc的语言，如php，可以在libc进行拦截。</li><li>对于没有使用libc的语言，如golang，可以在语言标准库上修改做拦截。</li></ul><h4 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h4><p>流量录制不仅要录制接口inbound请求流量，还要录制下游outbound请求流量，那如何将inbound请求和outbound请求关联起来呢？</p><blockquote><p>利用分布式追踪原理，用唯一的traceID将请求关联起来。</p></blockquote><p>对于http服务，每个请求会单独开一个goroutine处理，对于大部分的场景都是在一个goroutine完成。可以使用goroutineID来关联inbound和outbound请求，对于大部分场景都适用。</p><p>对于少数并发等不在一个goroutine处理的请求，就需要传同一个id来标识，需要少量业务代码改动。</p><h4 id="流量存储"><a href="#流量存储" class="headerlink" title="流量存储"></a>流量存储</h4><ul><li><p>方便ES检索</p></li><li><p>二进制安全，数据不丢失</p></li></ul><h4 id="流量回放"><a href="#流量回放" class="headerlink" title="流量回放"></a>流量回放</h4><p>流量回放的前提是基于录制的流量进行操作。</p><p>如果录制的流量只有Inbound请求，没有Outbound请求，那么，回放过程非常简单。只需构造http请求发给SUT，等待SUT返回Response后进行对比即可。</p><p>但实际业务中，不仅会有Outbound请求，而且Outbound请求还很多，协议也各种各样。</p><p>因此，流量回放首要解决的问题有：</p><ol><li>如何拦截SUT的Outbound请求，将其转发给Agent的Mock Server。</li><li>如何在录制的流量里，选择最合适的Outbound返回给SUT。</li></ol><p>@<a href="https://github.com/didi/sharingan/wiki">https://github.com/didi/sharingan/wiki</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h4&gt;&lt;p&gt;将线上的真实请求流量录制下来，包含调用下游服务的流量。&lt;/p&gt;
&lt;h4 id=&quot;拦截点选择&quot;&gt;&lt;a href=&quot;#拦截点选择&quot; class=</summary>
      
    
    
    
    
    <category term="test" scheme="https://sun-moon-star-star.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>墨子·修身</title>
    <link href="https://sun-moon-star-star.github.io/2021/02/10/mozi-xiushen/"/>
    <id>https://sun-moon-star-star.github.io/2021/02/10/mozi-xiushen/</id>
    <published>2021-02-10T03:51:20.000Z</published>
    <updated>2021-02-19T13:13:41.096Z</updated>
    
    <content type="html"><![CDATA[<h4 id="墨子·修身"><a href="#墨子·修身" class="headerlink" title="墨子·修身"></a>墨子·修身</h4><ul><li><p>君子战虽有陈，而勇为本焉。丧虽有礼，而哀为本焉。士虽有学，而行为本焉。是故置本不安者，无务丰末。近者不亲，无务来远。亲戚不附，无务外交。事无终始，无务多业。举物而暗，无务博闻。</p><blockquote><p>君子作战虽用阵势，但必以勇敢为本；办丧事虽讲礼仪，但必以哀痛为本；做官虽讲才识，但必以德行为本。所以立本不牢的，就不必讲究枝节的繁盛；身边的人不能亲近，就不必讲究招徕远方之民；亲戚不能使之归附，就不必讲究结纳外人；做一件事情有始无终，就不必谈起从事多种事业；举一件事物尚且弄不明白，就不必追求广见博闻。</p></blockquote></li><li><p>是故先王之治天下也，必察迩来远，君子察迩而迩修者也。见不修行，见毁，而反之身者也，此以怨省而行修矣。谮慝之言，无入之耳，批捍之声，无出之口，杀伤人之孩，无存之心，虽有诋讦之民，无所依矣。</p><blockquote><p>所以先王治理天下，必定要明察左右而招徕远人。君子能明察左右，左右之人也就能修养自己的品行了。君子不能修养自己的品行而受人诋毁，那就应当自我反省，因而怨少而品德日修。谗害诽谤之言不入于耳，攻击他人之语不出于口，伤害人的念头不存于心，这样，即使遇有好诋毁、攻击的人，也就无从施展了。</p></blockquote></li><li><p>故君子力事日强，愿欲日逾，设壮日盛。君子之道也，贫则见廉，富则见义，生则见爱，死则见哀。四行者不可虚假，反之身者也。藏于心者，无以竭爱。动于身者，无以竭恭。出于口者，无以竭驯。畅之四支，接之肌肤，华发隳颠，而犹弗舍者，其唯圣人乎！</p><blockquote><p>所以君子本身的力量一天比一天加强，志向一无比一天远大，庄敬的品行一天比一天完善。君子之道（应包括如下方面）：贫穷时表现出廉洁，富足时表现出恩义，对生者表示出慈爱，对死者表示出哀痛。这四种品行不是可以装出来的，而是必须自身具备的。凡是存在于内心的，是无穷的慈爱；举止于身体的，是无比的谦恭；谈说于嘴上的，是无比的雅驯。（让上述四种品行）畅达于四肢和肌肤，直到白发秃顶之时仍不肯舍弃，大概只有圣人吧！</p></blockquote></li><li><p>志不强者智不达，言不信者行不果。据财不能以分人者，不足与友。守道不笃，偏物不博，辩是非不察者，不足与游。本不固者末必几，雄而不修者，其后必惰，原浊者流不清，行不信者名必秏。名不徒生而誉不自长，功成名遂，名誉不可虚假，反之身者也。务言而缓行，虽辩必不听。多力而伐功，虽劳必不图。慧者心辩而不繁说，多力而不伐功，此以名誉扬天下。言无务为多而务为智，无务为文而务为察。故彼智无察，在身而情，反其路者也。善无主于心者不留，行莫辩于身者不立。名不可简而成也，誉不可巧而立也，君子以身戴行者也。思利寻焉，忘名忽焉，可以为士于天下者，未尝有也。</p><blockquote><p>意志不坚强的，智慧一定不高；说话不讲信用的，行动一定不果敢；拥有财富而不肯分给人的，不值得和他交友；守道不坚定，阅历事物不广博，辨别是非不清楚的，不值得和他交游。根本不牢的，枝节必危。光勇敢而不注重品行修养的，后必懒惰。源头浊的流不清，行为无信的人名声必受损害，声誉不会无故产生和自己增长。功成了必然名就，名誉不可虚假，必须反求诸己。专说而行动迟缓，虽然会说，但没人听信。出力多而自夸功劳，虽劳苦而不可取。聪明人心里明白而不多说，努力作事而不夸说自己的功劳，因此名誉扬于天下。说话不图繁多而讲究富有智慧，不图文采而讲究明白。所以既无智慧又不能审察，加上自身又懒惰，则必背离正道而行了。善不从本心生出就不能保留，行不由本身审辨就不能树立，名望不会由茍简而成，声誉不会因诈伪而立，君子是言行合一的。以图利为重，忽视立名，（这样）而可以成为天下贤士的人，还不曾有过。</p></blockquote></li></ul><p>@<a href="https://ctext.org/mozi/self-cultivation/zhs">https://ctext.org/mozi/self-cultivation/zhs</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;墨子·修身&quot;&gt;&lt;a href=&quot;#墨子·修身&quot; class=&quot;headerlink&quot; title=&quot;墨子·修身&quot;&gt;&lt;/a&gt;墨子·修身&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;君子战虽有陈，而勇为本焉。丧虽有礼，而哀为本焉。士虽有学，而行为本焉。是故置本不安者，无务丰末。近</summary>
      
    
    
    
    
    <category term="read" scheme="https://sun-moon-star-star.github.io/tags/read/"/>
    
  </entry>
  
</feed>
